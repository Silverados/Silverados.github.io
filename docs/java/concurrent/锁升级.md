# 锁升级和对比
递增分为4种状态：无锁、偏向锁、轻量级锁、重量级锁
只能升级，不能降级（提高获得锁和释放锁的效率）

## 偏向锁
Hotspot的作者发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。
1. 当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储锁偏向的线程ID。
2. 在下次线程进入或者退出同步块时，测试对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。
3. 如果测试成功，表示线程已经获得了锁，失败则需要再测试`Mark Word`中偏向锁的标识是否设置为1（表示当前是偏向锁）如果没有设置则使用`CAS`竞争锁，否则尝试使用CAS将对象头的偏向锁指向当前线程。

### 偏向锁的撤销：
偏向锁使用了一种等到竞争出现才释放锁的机制。
1. 首先暂停拥有偏向锁的线程。然后检查持有偏向锁的线程是否存活，如果不处于活动状态，将对象头设置为无锁状态。
2. 如果线程存活，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录、栈中的锁记录和对象头的`Mark Word`要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

### 偏向锁相关的JVM参数
- `-XX:BiasedLockingStartupDelay=0`: 设置应用程序启动后启动偏向锁的延迟
- `-XX:UseBiasedLocking=false`: 关闭偏向锁

## 轻量级锁
### 轻量级加锁：
1. 线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中（Displaced Mark Word）然后线程尝试使用CAS将对象头的Mark Word替换为指向锁记录的指针。
2. 如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。
3. 自旋达到一定次数后会膨胀成重量级锁。

### 轻量级解锁：
轻量级解锁时，使用原子的CAS操作将Displaced Mark Word替换回对象头，如果成功表示没有竞争发生，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

### 锁的优缺点对比

|  锁   |                 优点                 |            缺点            |       适用场景        |
|:----:|:----------------------------------:|:------------------------:|:-----------------:|
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗  | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 |        竞争的线程不会阻塞，提高了程序的响应速度        | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应事件 同步块执行速度非常快 |
| 重量级锁 |         线程竞争不使用自旋，不会消耗CPU          |       线程阻塞，响应事件缓慢        |  追求吞吐量 同步块执行时间较长  |

### 轻量级相关的JVM参数
- `-XX:UseSpinning=true`: 启用自旋
- `-XX:PreBlockSpin=10`: 尝试获取轻量级锁之前进行的自旋次数
