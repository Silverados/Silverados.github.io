# 设计模式

设计模式分为3类：
- 创建型: 对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
- 结构型: 类或对象组合的问题。
- 行为型: 类或对象之间的交互的问题。

创建型再细分可以分为：
- 单例模式：确保一个类只有一个实例，并提供一个全局访问点。
- 工厂模式：提供一个封装在称为工厂的类中的静态方法，以隐藏实现逻辑，并使客户端代码专注于使用而不是初始化新对象。
- 抽象工厂模式：提供一个接口，用于创建一系列相关或依赖的对象，而无需指定它们的具体类。
- 建造者模式：将复杂对象的构造和表示分离开，以便相同的构造过程可以创建不同的表示。
- 原型模式：使用原型实例指定要创建的对象的类型，并通过复制这个原型来创建新对象。

结构型细分：
- 适配器模式：将类的接口转换为客户期望的另一个接口。适配器允许由于接口不兼容而无法在一起工作的类一起工作。
- 装饰器模式：动态地将额外的责任附加到对象上。装饰器为扩展功能提供了一种灵活的替代方法
- 代理模式：为另一个对象提供代理或占位符以控制对其的访问。
- 外观模式：为子系统中的一组接口提供统一的接口。Facade定义了一个更高级的接口，使子系统更容易使用。
- 桥接模式：将实例和抽象解耦，这样两者可以互不依赖的变化。
- 组合模式：将对象组合成树结构来表示部分-整体层次结构。复合允许客户端统一地对待单个对象和对象的组合。
- 享元模式：使用共享可以有效地支持大量细粒度对象。 

行为型细分：
- 策略模式：定义一系列算法，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户端而变化。
- 模板方法模式：在操作中定义算法的框架，将一些步骤延迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。
- 观察者模式：定义对象之间一对多的依赖关系，这样当一个对象改变状态时，它的所有依赖项都会被通知并自动更新。
- 迭代器模式：提供一种顺序访问聚合对象元素的方法，而不暴露其底层表示形式。
- 责任链模式：通过给多个对象处理请求的机会，避免将请求的发送方与接收方耦合。将接收对象连接起来，并沿着链传递请求，直到有一个对象处理它。
- 命令模式：将一个请求封装为一个对象，从而使您能够使用不同的请求、队列或日志请求来参数化客户机，并支持可撤消的操作。
- 备忘录模式：在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后将对象恢复到此状态。
- 状态模式：允许一个对象在内部状态改变时改变它的行为。这个对象看起来像是改变了它的类。
- 访问者模式：表示要对对象结构的元素执行的操作。Visitor允许您定义一个新的操作，而不更改它所操作的元素的类。
- 中介者模式：定义一个对象来封装一组对象的交互方式。中介通过避免对象显式地相互引用来促进松耦合，并且它允许您独立地改变它们的交互。
- 解释器模式：给定一种语言，请定义其语法的表示形式，以及使用该表示形式来解释该语言中的句子的解释器。

## 面试常问
- 谈谈常用的设计模式。
- 什么是饿汉式？什么是懒汉式？
- XXX框架用到了哪些设计模式。

## 推荐阅读
https://www.zhihu.com/tardis/zm/art/345126462?source_id=1005